{"ast":null,"code":"'use strict';\n/* global window */\n\nvar restore = capture();\n/* istanbul ignore next - Don't allow Prism to run on page load in browser. */\n\nvar ctx = typeof window === 'undefined' ? {} : window;\nctx.Prism = {\n  manual: true\n  /* Load all stuff in `prism.js` itself, except for\n   * `prism-file-highlight.js`.\n   * The wrapped non-leaky grammars are loaded instead of\n   * Prismâ€™s originals. */\n\n};\n\nvar h = require('hastscript');\n\nvar Prism = require('prismjs/components/prism-core');\n\nvar markup = require('./lang/markup');\n\nvar css = require('./lang/css');\n\nvar clike = require('./lang/clike');\n\nvar js = require('./lang/javascript');\n\nrestore();\nvar own = {}.hasOwnProperty;\n/* Inherit. */\n\nfunction Refractor() {}\n\nRefractor.prototype = Prism;\n/* Construct. */\n\nvar refract = new Refractor();\n/* Expose. */\n\nmodule.exports = refract;\n/* Create. */\n\nrefract.highlight = highlight;\nrefract.register = register;\nrefract.registered = registered;\n/* Register bundled grammars. */\n\nregister(markup);\nregister(css);\nregister(clike);\nregister(js);\nrefract.util.encode = encode;\nrefract.Token.stringify = stringify;\n\nfunction register(grammar) {\n  if (typeof grammar !== 'function' || !grammar.displayName) {\n    throw new Error('Expected `function` for `grammar`, got `' + grammar + '`');\n  }\n  /* Do not duplicate registrations. */\n\n\n  if (refract.languages[grammar.displayName] === undefined) {\n    grammar(refract);\n  }\n}\n\nfunction highlight(value, name) {\n  var sup = Prism.highlight;\n\n  if (typeof value !== 'string') {\n    throw new Error('Expected `string` for `value`, got `' + value + '`');\n  }\n\n  if (typeof name !== 'string') {\n    throw new Error('Expected `string` for `name`, got `' + name + '`');\n  }\n\n  if (!own.call(refract.languages, name)) {\n    throw new Error('Unknown language: `' + name + '` is not registered');\n  }\n\n  return sup.call(this, value, refract.languages[name], name);\n}\n\nfunction registered(language) {\n  if (typeof language !== 'string') {\n    throw new Error('Expected `string` for `language`, got `' + language + '`');\n  }\n\n  return own.call(refract.languages, language);\n}\n\nfunction stringify(value, language, parent) {\n  var env;\n\n  if (typeof value === 'string') {\n    return {\n      type: 'text',\n      value: value\n    };\n  }\n\n  if (refract.util.type(value) === 'Array') {\n    return stringifyAll(value, language);\n  }\n\n  env = {\n    type: value.type,\n    content: refract.Token.stringify(value.content, language, parent),\n    tag: 'span',\n    classes: ['token', value.type],\n    attributes: {},\n    language: language,\n    parent: parent\n  };\n\n  if (value.alias) {\n    env.classes = env.classes.concat(value.alias);\n  }\n\n  refract.hooks.run('wrap', env);\n  return h(env.tag + '.' + env.classes.join('.'), env.attributes, env.content);\n}\n\nfunction stringifyAll(values, language) {\n  var result = [];\n  var length = values.length;\n  var index = -1;\n  var value;\n\n  while (++index < length) {\n    value = values[index];\n\n    if (value !== '' && value !== null && value !== undefined) {\n      result.push(value);\n    }\n  }\n\n  index = -1;\n  length = result.length;\n\n  while (++index < length) {\n    value = result[index];\n    result[index] = refract.Token.stringify(value, language, result);\n  }\n\n  return result;\n}\n\nfunction encode(tokens) {\n  return tokens;\n}\n\nfunction capture() {\n  var defined = 'Prism' in global;\n  /* istanbul ignore next */\n\n  var current = defined ? global.Prism : undefined;\n  return restore;\n\n  function restore() {\n    /* istanbul ignore else - Clean leaks after Prism. */\n    if (defined) {\n      global.Prism = current;\n    } else {\n      delete global.Prism;\n    }\n\n    defined = undefined;\n    current = undefined;\n  }\n}","map":null,"metadata":{},"sourceType":"script"}