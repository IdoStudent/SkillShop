{"ast":null,"code":"'use strict';\n\nmodule.exports = http;\nhttp.displayName = 'http';\nhttp.aliases = [];\n\nfunction http(Prism) {\n  Prism.languages.http = {\n    'request-line': {\n      pattern: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\shttps?:\\/\\/\\S+\\sHTTP\\/[0-9.]+/m,\n      inside: {\n        // HTTP Verb\n        property: /^(?:POST|GET|PUT|DELETE|OPTIONS|PATCH|TRACE|CONNECT)\\b/,\n        // Path or query argument\n        'attr-name': /:\\w+/\n      }\n    },\n    'response-status': {\n      pattern: /^HTTP\\/1.[01] \\d+.*/m,\n      inside: {\n        // Status, e.g. 200 OK\n        property: {\n          pattern: /(^HTTP\\/1.[01] )\\d+.*/i,\n          lookbehind: true\n        }\n      }\n    },\n    // HTTP header name\n    'header-name': {\n      pattern: /^[\\w-]+:(?=.)/m,\n      alias: 'keyword'\n    } // Create a mapping of Content-Type headers to language definitions\n\n  };\n  var httpLanguages = {\n    'application/json': Prism.languages.javascript,\n    'application/xml': Prism.languages.markup,\n    'text/xml': Prism.languages.markup,\n    'text/html': Prism.languages.markup // Insert each content type parser that has its associated language\n    // currently loaded.\n\n  };\n\n  for (var contentType in httpLanguages) {\n    if (httpLanguages[contentType]) {\n      var options = {};\n      options[contentType] = {\n        pattern: new RegExp('(content-type:\\\\s*' + contentType + '[\\\\w\\\\W]*?)(?:\\\\r?\\\\n|\\\\r){2}[\\\\w\\\\W]*', 'i'),\n        lookbehind: true,\n        inside: {\n          rest: httpLanguages[contentType]\n        }\n      };\n      Prism.languages.insertBefore('http', 'header-name', options);\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}