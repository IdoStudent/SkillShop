{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _react = require(\"react\");\n\nvar _stringifyObject = require(\"../stringifyObject\");\n\nvar _stringifyObject2 = _interopRequireDefault(_stringifyObject);\n\nvar _sortObject = require(\"./sortObject\");\n\nvar _sortObject2 = _interopRequireDefault(_sortObject);\n\nvar _parseReactElement = require(\"./../parser/parseReactElement\");\n\nvar _parseReactElement2 = _interopRequireDefault(_parseReactElement);\n\nvar _formatTreeNode = require(\"./formatTreeNode\");\n\nvar _formatTreeNode2 = _interopRequireDefault(_formatTreeNode);\n\nvar _spacer = require(\"./spacer\");\n\nvar _spacer2 = _interopRequireDefault(_spacer);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction noRefCheck() {}\n\nexports.default = function (value, inline, lvl, options) {\n  var normalizedValue = (0, _sortObject2.default)(value);\n  var stringifiedValue = (0, _stringifyObject2.default)(normalizedValue, {\n    transform: function transform(currentObj, prop, originalResult) {\n      var currentValue = currentObj[prop];\n\n      if (currentValue && (0, _react.isValidElement)(currentValue)) {\n        return (0, _formatTreeNode2.default)((0, _parseReactElement2.default)(currentValue, options), true, lvl, options);\n      }\n\n      if (typeof currentValue === \"function\") {\n        return noRefCheck;\n      }\n\n      return originalResult;\n    }\n  });\n\n  if (inline) {\n    return stringifiedValue.replace(/\\s+/g, \" \").replace(/{ /g, \"{\").replace(/ }/g, \"}\").replace(/\\[ /g, \"[\").replace(/ ]/g, \"]\");\n  } // Replace tabs with spaces, and add necessary indentation in front of each new line\n\n\n  return stringifiedValue.replace(/\\t/g, (0, _spacer2.default)(1, options.tabStop)).replace(/\\n([^$])/g, \"\\n\" + (0, _spacer2.default)(lvl + 1, options.tabStop) + \"$1\");\n};","map":{"version":3,"sources":["../../src/formatter/formatComplexDataStructure.js"],"names":["normalizedValue","stringifiedValue","transform","currentValue","currentObj"],"mappings":";;;;;;AAEA,IAAA,gBAAA,GAAA,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAA,iBAAA,GAAA,sBAAA,CAAA,gBAAA,CAAA;;;;AACA,IAAA,YAAA,GAAA,sBAAA,CAAA,WAAA,CAAA;;;;AACA,IAAA,mBAAA,GAAA,sBAAA,CAAA,kBAAA,CAAA;;;;AACA,IAAA,gBAAA,GAAA,sBAAA,CAAA,eAAA,CAAA;;;;AACA,IAAA,QAAA,GAAA,sBAAA,CAAA,OAAA,CAAA;;;;;;;;AAGA,SAAA,UAAA,GAAsB,CAAE;;kBAET,UAAA,KAAA,EAAA,MAAA,EAAA,GAAA,EAAA,OAAA,EAAA;AAMb,MAAMA,eAAAA,GAAkB,CAAA,GAAA,YAAA,CAAA,OAAA,EAAxB,KAAwB,CAAxB;AAEA,MAAMC,gBAAAA,GAAmB,CAAA,GAAA,iBAAA,CAAA,OAAA,EAAA,eAAA,EAA2B;AAClDC,IAAAA,SAAAA,EAAW,SAAA,SAAA,CAAA,UAAA,EAAA,IAAA,EAAA,cAAA,EAAsC;AAC/C,UAAMC,YAAAA,GAAeC,UAAAA,CAArB,IAAqBA,CAArB;;AAEA,UAAID,YAAAA,IAAgB,CAAA,GAAA,MAAA,CAAA,cAAA,EAApB,YAAoB,CAApB,EAAkD;AAChD,eAAO,CAAA,GAAA,gBAAA,CAAP,OAAO,EAMR,CAAA,GAAA,mBAAA,CAAA,OAAA,EAAA,YAAA,EAAA,OAAA,CANQ,E,IAAA,EAQT,GARS,EASP,OATO,CAAP;;;AAaH,UAAA,OAAA,YAAA,KAAA,UAAA,EAAA;AAlBH,eAAA,UAAA;;;AAsBE,aAAA,cAAA;AAMD;AA5BmD,GAA3B,CAAzB;;AA+BA,MAAA,MAAA,EAAA;;GAvCa,C","sourcesContent":["/* @flow */\n\nimport { isValidElement } from 'react';\nimport stringify from '../stringifyObject';\nimport sortObject from './sortObject';\nimport parseReactElement from './../parser/parseReactElement';\nimport formatTreeNode from './formatTreeNode';\nimport spacer from './spacer';\nimport type { Options } from './../options';\n\nfunction noRefCheck() {}\n\nexport default (\n  value: Object | Array<any>,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const normalizedValue = sortObject(value);\n\n  const stringifiedValue = stringify(normalizedValue, {\n    transform: (currentObj, prop, originalResult) => {\n      const currentValue = currentObj[prop];\n\n      if (currentValue && isValidElement(currentValue)) {\n        return formatTreeNode(\n          parseReactElement(currentValue, options),\n          true,\n          lvl,\n          options\n        );\n      }\n\n      if (typeof currentValue === 'function') {\n        return noRefCheck;\n      }\n\n      return originalResult;\n    },\n  });\n\n  if (inline) {\n    return stringifiedValue\n      .replace(/\\s+/g, ' ')\n      .replace(/{ /g, '{')\n      .replace(/ }/g, '}')\n      .replace(/\\[ /g, '[')\n      .replace(/ ]/g, ']');\n  }\n\n  // Replace tabs with spaces, and add necessary indentation in front of each new line\n  return stringifiedValue\n    .replace(/\\t/g, spacer(1, options.tabStop))\n    .replace(/\\n([^$])/g, `\\n${spacer(lvl + 1, options.tabStop)}$1`);\n};\n"]},"metadata":{},"sourceType":"module"}