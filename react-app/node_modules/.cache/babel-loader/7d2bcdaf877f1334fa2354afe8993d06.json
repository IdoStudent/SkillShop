{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _formatReactElementNode = require(\"./formatReactElementNode\");\n\nvar _formatReactElementNode2 = _interopRequireDefault(_formatReactElementNode);\n\nvar _formatReactFragmentNode = require(\"./formatReactFragmentNode\");\n\nvar _formatReactFragmentNode2 = _interopRequireDefault(_formatReactFragmentNode);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar jsxStopChars = [\"<\", \">\", \"{\", \"}\"];\n\nvar shouldBeEscaped = function shouldBeEscaped(s) {\n  return jsxStopChars.some(function (jsxStopChar) {\n    return s.includes(jsxStopChar);\n  });\n};\n\nvar escape = function escape(s) {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return \"{`\" + s + \"`}\";\n};\n\nvar preserveTrailingSpace = function preserveTrailingSpace(s) {\n  var result = s;\n\n  if (result.endsWith(\" \")) {\n    result = result.replace(/^(\\S*)(\\s*)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(\" \")) {\n    result = result.replace(/^(\\s*)(\\S*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexports.default = function (node, inline, lvl, options) {\n  if (node.type === \"number\") {\n    return String(node.value);\n  }\n\n  if (node.type === \"string\") {\n    return node.value ? \"\" + preserveTrailingSpace(escape(String(node.value))) : \"\";\n  }\n\n  if (node.type === \"ReactElement\") {\n    return (0, _formatReactElementNode2.default)(node, inline, lvl, options);\n  }\n\n  if (node.type === \"ReactFragment\") {\n    return (0, _formatReactFragmentNode2.default)(node, inline, lvl, options);\n  }\n\n  throw new TypeError('Unknow format type \"' + node.type + '\"');\n};","map":{"version":3,"sources":["../../src/formatter/formatTreeNode.js"],"names":["s","jsxStopChar","result","node"],"mappings":";;;;;;AAEA,IAAA,wBAAA,GAAA,sBAAA,CAAA,uBAAA,CAAA;;;;AACA,IAAA,yBAAA,GAAA,sBAAA,C,wBAAA,CAAA;;;;;;AAIA;;AACwB,IAAA,YACtB,GAAA,CAAA,GAAA,EAAA,GAAA,EAAkB,GAAlB,EAAkB,GAAlB,CADsB;;AACJ,IAAA,eAAeA,GAAWC,SAA1B,eAA0BA,CAA1B,CAA0BA,EAA1B;AADI,SAAA,YAAA,CAAA,IAAA,CAAA,UAAA,WAAA,EAAA;AAAxB,WAAA,CAAA,CAAA,QAAA,CAAA,WAAA,CAAA;GAAwB,CAAA;AAGxB,CAFoB;;AAIhB,IAAA,MAAA,GAAA,SAAA,MAAA,CAAA,CAAA,EAAA;AACD,MAAA,CAAA,eAAA,CAAA,CAAA,CAAA,EAAA;;AAED;;;AAGF,CANI;;AAQF,IAAA,qBAAA,GAA0B,SAAA,qBAAA,CAAA,CAAA,EAAA;AACxBC,MAAAA,MAAAA,GAAAA,CAAAA;;AACD,MAAA,MAAA,CAAA,QAAA,CAAA,GAAA,CAAA,EAAA;;AAED;;AAEC,MAAA,MAAA,CAAA,UAAA,CAAA,GAAA,CAAA,EAAA;;AAED;;;AAGa,CAXb;;AAkBE,OAAA,CAAA,OAAA,GAAcC,UAAd,IAAcA,EAAd,MAAcA,EAAd,GAAcA,EAAd,OAAcA,EAAd;AACD,MAAA,IAAA,CAAA,IAAA,KAAA,QAAA,EAAA;;AAED;;AAIC,MAAA,IAAA,CAAA,IAAA,KAAA,QAAA,EAAA;wBAEGA,KAAAA,qBAAJ,CAAA,MAAkC,CAAA,MAAA,CAAA,IAAA,CAAA,KAAA,CAAA,CAAlC,C,GACE,E;AACD;;AAED,MAAIA,IAAAA,CAAAA,IAAAA,KAAJ,cAAA,EAAA;AACE,WAAO,CAAA,GAAA,wBAAA,CAAA,OAAA,EAAA,IAAA,EAAA,MAAA,EAAA,GAAA,EAAP,OAAO,CAAP;AACD;;AAED,MAAA,IAAM,CAAA,IAAN,KAAM,eAAN,EAAA;;;;;CAjBE","sourcesContent":["/* @flow */\n\nimport formatReactElementNode from './formatReactElementNode';\nimport formatReactFragmentNode from './formatReactFragmentNode';\nimport type { Options } from './../options';\nimport type { TreeNode } from './../tree';\n\nconst jsxStopChars = ['<', '>', '{', '}'];\nconst shouldBeEscaped = (s: string) =>\n  jsxStopChars.some(jsxStopChar => s.includes(jsxStopChar));\n\nconst escape = (s: string) => {\n  if (!shouldBeEscaped(s)) {\n    return s;\n  }\n\n  return `{\\`${s}\\`}`;\n};\n\nconst preserveTrailingSpace = (s: string) => {\n  let result = s;\n  if (result.endsWith(' ')) {\n    result = result.replace(/^(\\S*)(\\s*)$/, \"$1{'$2'}\");\n  }\n\n  if (result.startsWith(' ')) {\n    result = result.replace(/^(\\s*)(\\S*)$/, \"{'$1'}$2\");\n  }\n\n  return result;\n};\n\nexport default (\n  node: TreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  if (node.type === 'number') {\n    return String(node.value);\n  }\n\n  if (node.type === 'string') {\n    return node.value\n      ? `${preserveTrailingSpace(escape(String(node.value)))}`\n      : '';\n  }\n\n  if (node.type === 'ReactElement') {\n    return formatReactElementNode(node, inline, lvl, options);\n  }\n\n  if (node.type === 'ReactFragment') {\n    return formatReactFragmentNode(node, inline, lvl, options);\n  }\n\n  throw new TypeError(`Unknow format type \"${node.type}\"`);\n};\n"]},"metadata":{},"sourceType":"module"}