{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _spacer = require(\"./spacer\");\n\nvar _spacer2 = _interopRequireDefault(_spacer);\n\nvar _formatTreeNode = require(\"./formatTreeNode\");\n\nvar _formatTreeNode2 = _interopRequireDefault(_formatTreeNode);\n\nvar _formatProp2 = require(\"./formatProp\");\n\nvar _formatProp3 = _interopRequireDefault(_formatProp2);\n\nvar _mergeSiblingPlainStringChildrenReducer = require(\"./mergeSiblingPlainStringChildrenReducer\");\n\nvar _mergeSiblingPlainStringChildrenReducer2 = _interopRequireDefault(_mergeSiblingPlainStringChildrenReducer);\n\nvar _propNameSorter = require(\"./propNameSorter\");\n\nvar _propNameSorter2 = _interopRequireDefault(_propNameSorter);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar compensateMultilineStringElementIndentation = function compensateMultilineStringElementIndentation(element, formattedElement, inline, lvl, options) {\n  var tabStop = options.tabStop;\n\n  if (element.type === \"string\") {\n    return formattedElement.split(\"\\n\").map(function (line, offset) {\n      if (offset === 0) {\n        return line;\n      }\n\n      return \"\" + (0, _spacer2.default)(lvl, tabStop) + line;\n    }).join(\"\\n\");\n  }\n\n  return formattedElement;\n};\n\nvar formatOneChildren = function formatOneChildren(inline, lvl, options) {\n  return function (element) {\n    return compensateMultilineStringElementIndentation(element, (0, _formatTreeNode2.default)(element, inline, lvl, options), inline, lvl, options);\n  };\n};\n\nvar onlyPropsWithOriginalValue = function onlyPropsWithOriginalValue(defaultProps, props) {\n  return function (propName) {\n    var haveDefaultValue = Object.keys(defaultProps).includes(propName);\n    return !haveDefaultValue || haveDefaultValue && defaultProps[propName] !== props[propName];\n  };\n};\n\nvar isInlineAttributeTooLong = function isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (0, _spacer2.default)(lvl, tabStop).length + inlineAttributeString.length > maxInlineAttributesLineLength;\n};\n\nvar shouldRenderMultilineAttr = function shouldRenderMultilineAttr(attributes, inlineAttributeString, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength) {\n  return (isInlineAttributeTooLong(attributes, inlineAttributeString, lvl, tabStop, maxInlineAttributesLineLength) || containsMultilineAttr) && !inline;\n};\n\nexports.default = function (node, inline, lvl, options) {\n  var type = node.type,\n      _node$displayName = node.displayName,\n      displayName = _node$displayName === undefined ? \"\" : _node$displayName,\n      childrens = node.childrens,\n      _node$props = node.props,\n      props = _node$props === undefined ? {} : _node$props,\n      _node$defaultProps = node.defaultProps,\n      defaultProps = _node$defaultProps === undefined ? {} : _node$defaultProps;\n\n  if (type !== \"ReactElement\") {\n    throw new Error('The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ' + type);\n  }\n\n  var filterProps = options.filterProps,\n      maxInlineAttributesLineLength = options.maxInlineAttributesLineLength,\n      showDefaultProps = options.showDefaultProps,\n      sortProps = options.sortProps,\n      tabStop = options.tabStop;\n  var out = \"<\" + displayName;\n  var outInlineAttr = out;\n  var outMultilineAttr = out;\n  var containsMultilineAttr = false;\n  var visibleAttributeNames = [];\n  Object.keys(props).filter(function (propName) {\n    return filterProps.indexOf(propName) === -1;\n  }).filter(onlyPropsWithOriginalValue(defaultProps, props)).forEach(function (propName) {\n    return visibleAttributeNames.push(propName);\n  });\n  Object.keys(defaultProps).filter(function (defaultPropName) {\n    return filterProps.indexOf(defaultPropName) === -1;\n  }).filter(function () {\n    return showDefaultProps;\n  }).filter(function (defaultPropName) {\n    return !visibleAttributeNames.includes(defaultPropName);\n  }).forEach(function (defaultPropName) {\n    return visibleAttributeNames.push(defaultPropName);\n  });\n  var attributes = visibleAttributeNames.sort((0, _propNameSorter2.default)(sortProps));\n  attributes.forEach(function (attributeName) {\n    var _formatProp = (0, _formatProp3.default)(attributeName, Object.keys(props).includes(attributeName), props[attributeName], Object.keys(defaultProps).includes(attributeName), defaultProps[attributeName], inline, lvl, options),\n        attributeFormattedInline = _formatProp.attributeFormattedInline,\n        attributeFormattedMultiline = _formatProp.attributeFormattedMultiline,\n        isMultilineAttribute = _formatProp.isMultilineAttribute;\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n  outMultilineAttr += \"\\n\" + (0, _spacer2.default)(lvl, tabStop);\n\n  if (shouldRenderMultilineAttr(attributes, outInlineAttr, containsMultilineAttr, inline, lvl, tabStop, maxInlineAttributesLineLength)) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    var newLvl = lvl + 1;\n    out += \">\";\n\n    if (!inline) {\n      out += \"\\n\";\n      out += (0, _spacer2.default)(newLvl, tabStop);\n    }\n\n    out += childrens.reduce(_mergeSiblingPlainStringChildrenReducer2.default, []).map(formatOneChildren(inline, newLvl, options)).join(!inline ? \"\\n\" + (0, _spacer2.default)(newLvl, tabStop) : \"\");\n\n    if (!inline) {\n      out += \"\\n\";\n      out += (0, _spacer2.default)(newLvl - 1, tabStop);\n    }\n\n    out += \"</\" + displayName + \">\";\n  } else {\n    if (!isInlineAttributeTooLong(attributes, outInlineAttr, lvl, tabStop, maxInlineAttributesLineLength)) {\n      out += \" \";\n    }\n\n    out += \"/>\";\n  }\n\n  return out;\n};","map":{"version":3,"sources":["../../src/formatter/formatReactElementNode.js"],"names":["formattedElement","formatOneChildren","compensateMultilineStringElementIndentation","isInlineAttributeTooLong","maxInlineAttributesLineLength","displayName","childrens","showDefaultProps","options","out","Object","attributes","attributeFormattedInline","attributeFormattedMultiline","isMultilineAttribute","containsMultilineAttr","outMultilineAttr","newLvl"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport spacer from './spacer';\nimport formatTreeNode from './formatTreeNode';\nimport formatProp from './formatProp';\nimport mergeSiblingPlainStringChildrenReducer from './mergeSiblingPlainStringChildrenReducer';\nimport propNameSorter from './propNameSorter';\nimport type { Options } from './../options';\nimport type { ReactElementTreeNode } from './../tree';\n\nconst compensateMultilineStringElementIndentation = (\n  element,\n  formattedElement: string,\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => {\n  const { tabStop } = options;\n\n  if (element.type === 'string') {\n    return formattedElement\n      .split('\\n')\n      .map((line, offset) => {\n        if (offset === 0) {\n          return line;\n        }\n\n        return `${spacer(lvl, tabStop)}${line}`;\n      })\n      .join('\\n');\n  }\n\n  return formattedElement;\n};\n\nconst formatOneChildren = (\n  inline: boolean,\n  lvl: number,\n  options: Options\n) => element =>\n  compensateMultilineStringElementIndentation(\n    element,\n    formatTreeNode(element, inline, lvl, options),\n    inline,\n    lvl,\n    options\n  );\n\nconst onlyPropsWithOriginalValue = (defaultProps, props) => propName => {\n  const haveDefaultValue = Object.keys(defaultProps).includes(propName);\n  return (\n    !haveDefaultValue ||\n    (haveDefaultValue && defaultProps[propName] !== props[propName])\n  );\n};\n\nconst isInlineAttributeTooLong = (\n  attributes: string[],\n  inlineAttributeString: string,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean => {\n  if (!maxInlineAttributesLineLength) {\n    return attributes.length > 1;\n  }\n\n  return (\n    spacer(lvl, tabStop).length + inlineAttributeString.length >\n    maxInlineAttributesLineLength\n  );\n};\n\nconst shouldRenderMultilineAttr = (\n  attributes: string[],\n  inlineAttributeString: string,\n  containsMultilineAttr: boolean,\n  inline: boolean,\n  lvl: number,\n  tabStop: number,\n  maxInlineAttributesLineLength: ?number\n): boolean =>\n  (isInlineAttributeTooLong(\n    attributes,\n    inlineAttributeString,\n    lvl,\n    tabStop,\n    maxInlineAttributesLineLength\n  ) ||\n    containsMultilineAttr) &&\n  !inline;\n\nexport default (\n  node: ReactElementTreeNode,\n  inline: boolean,\n  lvl: number,\n  options: Options\n): string => {\n  const {\n    type,\n    displayName = '',\n    childrens,\n    props = {},\n    defaultProps = {},\n  } = node;\n\n  if (type !== 'ReactElement') {\n    throw new Error(\n      `The \"formatReactElementNode\" function could only format node of type \"ReactElement\". Given:  ${\n        type\n      }`\n    );\n  }\n\n  const {\n    filterProps,\n    maxInlineAttributesLineLength,\n    showDefaultProps,\n    sortProps,\n    tabStop,\n  } = options;\n\n  let out = `<${displayName}`;\n\n  let outInlineAttr = out;\n  let outMultilineAttr = out;\n  let containsMultilineAttr = false;\n\n  const visibleAttributeNames = [];\n\n  Object.keys(props)\n    .filter(propName => filterProps.indexOf(propName) === -1)\n    .filter(onlyPropsWithOriginalValue(defaultProps, props))\n    .forEach(propName => visibleAttributeNames.push(propName));\n\n  Object.keys(defaultProps)\n    .filter(defaultPropName => filterProps.indexOf(defaultPropName) === -1)\n    .filter(() => showDefaultProps)\n    .filter(defaultPropName => !visibleAttributeNames.includes(defaultPropName))\n    .forEach(defaultPropName => visibleAttributeNames.push(defaultPropName));\n\n  const attributes = visibleAttributeNames.sort(propNameSorter(sortProps));\n\n  attributes.forEach(attributeName => {\n    const {\n      attributeFormattedInline,\n      attributeFormattedMultiline,\n      isMultilineAttribute,\n    } = formatProp(\n      attributeName,\n      Object.keys(props).includes(attributeName),\n      props[attributeName],\n      Object.keys(defaultProps).includes(attributeName),\n      defaultProps[attributeName],\n      inline,\n      lvl,\n      options\n    );\n\n    if (isMultilineAttribute) {\n      containsMultilineAttr = true;\n    }\n\n    outInlineAttr += attributeFormattedInline;\n    outMultilineAttr += attributeFormattedMultiline;\n  });\n\n  outMultilineAttr += `\\n${spacer(lvl, tabStop)}`;\n\n  if (\n    shouldRenderMultilineAttr(\n      attributes,\n      outInlineAttr,\n      containsMultilineAttr,\n      inline,\n      lvl,\n      tabStop,\n      maxInlineAttributesLineLength\n    )\n  ) {\n    out = outMultilineAttr;\n  } else {\n    out = outInlineAttr;\n  }\n\n  if (childrens && childrens.length > 0) {\n    const newLvl = lvl + 1;\n\n    out += '>';\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl, tabStop);\n    }\n\n    out += childrens\n      .reduce(mergeSiblingPlainStringChildrenReducer, [])\n      .map(formatOneChildren(inline, newLvl, options))\n      .join(!inline ? `\\n${spacer(newLvl, tabStop)}` : '');\n\n    if (!inline) {\n      out += '\\n';\n      out += spacer(newLvl - 1, tabStop);\n    }\n    out += `</${displayName}>`;\n  } else {\n    if (\n      !isInlineAttributeTooLong(\n        attributes,\n        outInlineAttr,\n        lvl,\n        tabStop,\n        maxInlineAttributesLineLength\n      )\n    ) {\n      out += ' ';\n    }\n\n    out += '/>';\n  }\n\n  return out;\n};\n"]},"metadata":{},"sourceType":"module"}