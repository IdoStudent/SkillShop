{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _tree = require(\"./../tree\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar supportFragment = Boolean(_react.Fragment);\n\nvar getReactElementDisplayName = function getReactElementDisplayName(element) {\n  return element.type.displayName || element.type.name || ( // function name\n  typeof element.type === \"function\" // function without a name, you should provide one\n  ? \"No Display Name\" : element.type);\n};\n\nvar noChildren = function noChildren(propsValue, propName) {\n  return propName !== \"children\";\n};\n\nvar onlyMeaningfulChildren = function onlyMeaningfulChildren(children) {\n  return children !== true && children !== false && children !== null && children !== \"\";\n};\n\nvar filterProps = function filterProps(originalProps, cb) {\n  var filteredProps = {};\n  Object.keys(originalProps).filter(function (key) {\n    return cb(originalProps[key], key);\n  }).forEach(function (key) {\n    return filteredProps[key] = originalProps[key];\n  });\n  return filteredProps;\n};\n\nvar parseReactElement = function parseReactElement(element, options) {\n  var _options$displayName = options.displayName,\n      displayNameFn = _options$displayName === undefined ? getReactElementDisplayName : _options$displayName;\n\n  if (typeof element === \"string\") {\n    return (0, _tree.createStringTreeNode)(element);\n  } else if (typeof element === \"number\") {\n    return (0, _tree.createNumberTreeNode)(element);\n  } else if (!_react2.default.isValidElement(element)) {\n    throw new Error(\"react-element-to-jsx-string: Expected a React.Element, got `\" + (typeof element === \"undefined\" ? \"undefined\" : _typeof(element)) + \"`\");\n  }\n\n  var displayName = displayNameFn(element);\n  var props = filterProps(element.props, noChildren);\n\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  var key = element.key;\n\n  if (typeof key === \"string\" && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  var defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n\n  var childrens = _react2.default.Children.toArray(element.props.children).filter(onlyMeaningfulChildren).map(function (child) {\n    return parseReactElement(child, options);\n  });\n\n  if (supportFragment && element.type === _react.Fragment) {\n    return (0, _tree.createReactFragmentTreeNode)(key, childrens);\n  }\n\n  return (0, _tree.createReactElementTreeNode)(displayName, props, defaultProps, childrens);\n};\n\nexports.default = parseReactElement;","map":{"version":3,"sources":["../../src/parser/parseReactElement.js"],"names":["getReactElementDisplayName","element","noChildren","propName","onlyMeaningfulChildren","filterProps","filteredProps","Object","originalProps","parseReactElement","displayNameFn","displayName","props","defaultProps","childrens","supportFragment"],"mappings":";;;;;;AAEA,C;gDAEA,GAAA,CAAA,WAAA,KAAA,M;AAQA,C;;AAEA,IAAMA,MAAAA,GAAAA,OAAAA,CAAAA,OAAAA,CAAN;;AAGG,IAAA,OAAOC,GAAP,sBAAA,CAAmC,MAAnC,CAAA;;AAHH,IAAA,KAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAOA,SAAMC,sBAAN,CAAMA,GAAN,EAAmB;AAAA,SAA0BC,GAAAA,IAAAA,GAAAA,CAA1B,UAA0BA,GAA1B,GAA0BA,GAA1B;AAAA,IAAA,OAAA,EAAA;AAAA,GAAA;AAAnB;;AAEA,IAAMC,eAAAA,GAAAA,OAAyB,CAAA,MAAA,CAAzBA,QAAyB,CAA/B;;AAAA,IAAA,0BAAA,GAAA,SAAA,0BAAA,CAAA,OAAA,EAAA;SAMMC,OAAAA,CAAAA,IAAAA,CAAAA,WAAAA,IACJ,OAAMC,CAAAA,IAAN,CAAA,IADID,MACJ;;IAEAE,iB,GACU,OAAUC,CAAV,IAJNH,C;AAKO,CAXb;;;AAaE,SAAOC,QAAAA,KAAP,UAAA;AAPF,C;;AAUA,IAAMG,sBAAoB,GAApBA,SAAAA,sBAAAA,CAAoB,QAApBA,EAGS;AAAA,SAAA,QACQC,KADR,IAAA,I,kBAAA,I,iBAAA,IAGb,QAAI,KAAJ,EAHa;AAGb,CANF;;AAQS,IAAA,WAEK,GAAA,SAAA,WAAA,CAAL,aAAK,EAAL,EAAK,EAA+B;AACzC,MAAA,aAAM,GAAN,EAAA;6BAKF,M,CAAMC,UAAcD,GAAdC,EAAN;;AAEA,G,EACA,O,CAAIV,UAAJ,GAAIA,EAAJ;AACEW,WAAAA,aAAAA,CAAAA,GAAAA,CAAAA,GAAAA,aAAAA,CAAAA,GAAAA,CAAAA;AACD,G;AAED,SAAA,aAAA;AACA,CAhBO;;AAkBLA,IAAAA,iBAAAA,GAAAA,SAAAA,iBAAAA,CAAAA,OAAAA,EAAAA,OAAAA,EAAAA;AACD,MAAA,oBAAA,GAAA,OAAA,CAAA,WAAA;AAAA,M,gBAEKC,oBAAeR,KAArB,SAAMQ,GACAC,0BADAD,GAGC,oBALN;;;AAOD,WAAIE,CAAAA,GAAAA,KAAAA,CAAAA,oBAAAA,EAAJ,OAAIA,CAAJ;AACE,G,MAAA,IAAO,OAAA,OAAA,KAAA,QAAP,EAAA;AACD,WAAA,CAAA,GAAA,KAAA,CAAA,oBAAA,EAAA,OAAA,CAAA;GADC,M;AAGF,UAAO,IAAP,KAAO,CAtCT,kE,+DAAA,IA8CeN,GARN,CAAP;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAZEG","sourcesContent":["/* @flow */\n\nimport React, { type Element as ReactElement, Fragment } from 'react';\nimport type { Options } from './../options';\nimport {\n  createStringTreeNode,\n  createNumberTreeNode,\n  createReactElementTreeNode,\n  createReactFragmentTreeNode,\n} from './../tree';\nimport type { TreeNode } from './../tree';\n\nconst supportFragment = Boolean(Fragment);\n\nconst getReactElementDisplayName = (element: ReactElement<*>): string =>\n  element.type.displayName ||\n  element.type.name || // function name\n  (typeof element.type === 'function' // function without a name, you should provide one\n    ? 'No Display Name'\n    : element.type);\n\nconst noChildren = (propsValue, propName) => propName !== 'children';\n\nconst onlyMeaningfulChildren = (children): boolean =>\n  children !== true &&\n  children !== false &&\n  children !== null &&\n  children !== '';\n\nconst filterProps = (originalProps: {}, cb: (any, string) => boolean) => {\n  const filteredProps = {};\n\n  Object.keys(originalProps)\n    .filter(key => cb(originalProps[key], key))\n    .forEach(key => (filteredProps[key] = originalProps[key]));\n\n  return filteredProps;\n};\n\nconst parseReactElement = (\n  element: ReactElement<*> | string | number,\n  options: Options\n): TreeNode => {\n  const { displayName: displayNameFn = getReactElementDisplayName } = options;\n\n  if (typeof element === 'string') {\n    return createStringTreeNode(element);\n  } else if (typeof element === 'number') {\n    return createNumberTreeNode(element);\n  } else if (!React.isValidElement(element)) {\n    throw new Error(\n      `react-element-to-jsx-string: Expected a React.Element, got \\`${typeof element}\\``\n    );\n  }\n\n  const displayName = displayNameFn(element);\n\n  const props = filterProps(element.props, noChildren);\n  if (element.ref !== null) {\n    props.ref = element.ref;\n  }\n\n  const key = element.key;\n  if (typeof key === 'string' && key.search(/^\\./)) {\n    // React automatically add key=\".X\" when there are some children\n    props.key = key;\n  }\n\n  const defaultProps = filterProps(element.type.defaultProps || {}, noChildren);\n  const childrens = React.Children.toArray(element.props.children)\n    .filter(onlyMeaningfulChildren)\n    .map(child => parseReactElement(child, options));\n\n  if (supportFragment && element.type === Fragment) {\n    return createReactFragmentTreeNode(key, childrens);\n  }\n\n  return createReactElementTreeNode(\n    displayName,\n    props,\n    defaultProps,\n    childrens\n  );\n};\n\nexport default parseReactElement;\n"]},"metadata":{},"sourceType":"module"}